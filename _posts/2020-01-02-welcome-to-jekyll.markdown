---
layout: post
title:  "AFL改进方法"
date:   2020-12-16 19:31:29 +0900
---
AFL针对含有源码的漏洞挖掘测试
😁🤣
{% highlight ruby %}
./configure CC="afl-gcc" CXX="afl-g++"//指定编译选项
make clean //清除编译记录
make -j4 //进行编译


AFL基本原理，自定义的边缘覆盖率来识别程序控制流的局部变化，
a)	把用户提供的初始测试用例加载到队列
b)	从队列中获取下一个测试输入文件
c)	在保持程序行为的前提下，尝试修剪(trim)测试用例体积最小
d)	使用传统的模糊测试策略中的各种已有的研究方法，重复变异文件
e)	如果生成的变异结果能够驱动新的状态转换（通过插桩记录），把这一测试用例加入到队列中

在有测试程序源码的前提下，可以直接使用AFL代替gcc或者clang作为编译器
C程序CC=/path/to/afl/afl-gcc./configure
C++程序CXX=/path/to/afl/afl-g++
当测试 lib 库的时候，需要找到或者写入简单程序，从 stdin或者从文件读取数据，传入到被测试的 lib 库中。所以，以把被插桩的 lib 库以静态的方式连接到可执行文件显得至关重要。或者确保正确的.so 文件在程序运行时加载 （通过 LD_LI－BRARY_PATH）。最简单的选择是使用静态编译，通常采用以下方式：
CC=/path/to/afl/afl-gcc ./configure --disable-shared

了解决当前模糊测试技术中编译存在一定的盲目性以及变异生成的样本大多经过相同的高频路径的问题，提出实现了一种基于轻量级程序分析技术的二进制程序模糊测试方法。首先通过对目标二进制程序进行静态分析来筛选在模糊测试过程中阻碍样本文件深入程序内部比较指令，随后对目标文件进行插桩来获取比较指令中操作数的具体值，并根据具体值为比较指令建立实时的比较进度信息，通过比较进度衡量样本的重要程度。最后根据比较进度信息并结合启发式策略有针对性对样本文件进行变异，通过变异引导提高模糊测试中生成能够绕过程序规约检查的有效样本的效率。提高经过稀有路径的种子文件被选中的概率，考虑到程序规约检查中的magic值校验检查。
{% endhighlight %}
